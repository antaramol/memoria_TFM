\chapter{Conclusiones}\label{chp-04}

% quote from Einstein
\epigraph{If we knew what it was we were doing, it would not be called research, would it?}{Albert Einstein}

\lettrine[lraise=-0.1, lines=2, loversize=0.2]{U}{na} vez finalizado el proyecto, es momento de hacer una valoración del mismo. 
En este capítulo se exponen las conclusiones obtenidas tras la realización del proyecto, así como las posibles mejoras que se podrían realizar en un futuro.

\section{Cumplimiento de requisitos}
Después de haber estado enfocado en un proyecto exigente durante un periodo de tiempo prolongado, tener sentimientos encontrados es normal. 
Pensar que se podrían haber realizado más pruebas, o que se podría haber mejorado algún aspecto, es inevitable.

Sin embargo, hay que echar la vista atrás y ver de dónde venimos para entender el camino recorrido.
El objetivo principal del proyecto, que era crear y desplegar un modelo clasificador de audios ha sido cumplido.

Para entender el grado de éxito del proyecto, es necesario recordar los requisitos que se establecieron en el capítulo \ref{chp-02} y ver cuáles de ellos se han cumplido.

\subsubsection{Requisitos funcionales}
Se han cumplido todos los requisitos funcionales.
El modelo es capaz de clasificar audios de entrada en formato WAV, y el sistema es accesible desde cualquier navegador web.
Además, el proceso de entrenamiento es replicable, y se puede entrenar un nuevo modelo con nuevos datos.

No se determinó ningún porcentaje de acierto mínimo, pero esta característica sería algo normal en un proyecto de estas características.

\subsubsection{Requisitos operacionales}
Debido a la falta de pruebas exhaustivas, no se puede asegurar que el sistema cumpla los requisitos operacionales con un alto grado de confianza.
Por ejemplo, es accesible desde cualquier y en cualquier momento, pero no se ha realizado un estudio de la disponibilidad del sistema.

Tampoco sabemos cómo puede comportarse el sistema con una carga de trabajo elevada.
Queda pendiente para líneas futuras la elaboración de un estudio de rendimiento del sistema y verificación de los requisitos operacionales.

\subsubsection{Requisitos de diseño}
El sistema cumple con los requisitos de diseño establecidos.

Estos requisitos fueron establecidos conociendo la tecnología que se iba a utilizar, por lo que no ha habido ningún problema en este aspecto.
Sin embargo, en un proyecto real, el diseño deberá adaptarse al entorno en el que se vaya a desplegar el sistema y a las tecnologías disponibles.

\subsubsection{Requisitos de seguridad}
El sistema cumple el requisito \textbf{S.2}, ya que el servidor web utiliza el protocolo HTTPS para asegurar la comunicación con el cliente.

Sin embargo, al realizar el entrenamiento del modelo en una instancia remota, no se ha podido cumplir el requisito \textbf{S.1}.
Además, para garantizar la seguridad del sistema, sería necesario realizar un estudio de las vulnerabilidades del mismo.



\section{Lecciones aprendidas}
El aprendizaje adquirido durante el desarrollo del proyecto ha sido muy valioso.
Más allá de las cuestiones puramente técnicas, se han adquirido múltiples habilidades que serán de gran utilidad en el futuro.

El hecho de enfocar el proyecto como un problema real, obliga a imaginarse qué tipo de problemas pueden surgir y qué elección es la más adecuada para resolverlos.
Aunque muchos requisitos han sido obviados, sobre todo los relacionados con la seguridad, entender las implicaciones que tienen las decisiones tomadas es muy enriquecedor.

Quizás el mayor aprendizaje ha sido el relacionado con cómo los obstáculos han sido sorteados.
Es inevitable que surjan problemas durante el desarrollo de un proyecto, y muchos de ellos parecen bloquear el avance.
Sin embargo, es en estos puntos cuando hay que entender bien el problema para poder encontrar una solución, o un camino alternativo.

En relación con el previo acercamiento a esta problemática, muchos de estos obstáculos que antes bloqueaban el proyecto por completo, han podido ahora ser resueltos o evitados.
En esta línea, es importante entender que muchas veces la solución no es un camino recto, sino que a veces hay que tomar desvíos para poder llegar al destino.


\section{Líneas futuras}

Esta sección pretende servir de autocrítica y de guía para futuros proyectos que quieran continuar con el trabajo realizado.
Se van a enumerar los puntos que se consideran más importantes para mejorar el proyecto.


\subsection{Mejorar el modelo}
A pesar de contar con un modelo capaz de clasificar audios, hemos comprobado que los resultados pueden ser mejorables.
En particular, sería conveniente prestar atención a las clases más problemáticas para subir el porcentaje de acierto.

Para ello, se podrían realizar las siguientes acciones:
\begin{itemize}
    \item Aumentar el número de muestras de las clases más problemáticas.
    \item Ajustar parámetros de entrenamiento.
    \item Probar distintos modelos preentrenados.
    \item Probar técnicas de Data Augmentation.
\end{itemize}




\subsection{Añadir funcionalidad al sistema}
% Explicar que solo hace una cosa
Otro punto particularmente débil de la implementación final del sistema es que tiene una funcionalidad muy limitada.
El sistema es capaz de clasificar audios de entrada que se suponen válidos, pero nada más.

Sería interesante añadir funcionalidades que permitan al usuario interactuar con el sistema de forma más natural.
Por ejemplo, grabar de forma continua y detectar emociones dependientes del tiempo.
Esta nueva funcionalidad no se consigue simplemente grabando de forma continua y haciendo predicciones, sería conveniente añadir un bloque detector de actividad vocal.

Una posible futura mejora podría ser un sistema capaz de detetar palabras clave. 
El desarrollo de este tipo de sistemas es muy similar al de los clasificadores de emociones, pero se necesitaría un dataset de grabaciones de la palabra clave en cuestión.
Acompañado de un estudio de las palabras clave que pudieran resultar de interés, este nuevo sitema podría ser de gran utilidad al clasificador de emociones.

También se podría investigar cómo identificar el hablante.
Hasta el momento hemos supuesto que hay un solo hablante, pero en caso de que hubiera más de uno, sería interesante identificarlos para poder obtener información temporal de cada uno de ellos.


\subsection{Verificación de funcionamiento}
La verificación del funcionamiento de un sistema puede llegar a consumir la mayor parte del tiempo de desarrollo.
En proyectos cuya disponibilidad es crítica, o se necesita un alto grado de confianza en el sistema, es necesario realizar una verificación exhaustiva del mismo.

Asegurar que el sistema no va a fallar es muy complejo, y requiere de un estudio profundo de los posibles casos de uso.

Para nuestro caso de uso, la evaluación del modelo debe ser mucho más exhaustiva, contando con un dataset de test mucho más variado (audios en varios idiomas, con ruido de fondo, audios de baja calidad, audios sin palabras, grabaciones genuinas, etc.).

En cuanto al servidor web, se debería realizar una verificación de la disponibilidad del sistema, pruebas de carga, pruebas de seguridad, etc.

En este proyecto, se ha realizado una verificación básica del funcionamiento del sistema, pero no se ha profundizado en ella.



\subsection{Optimización de la solución}
Reducir los recursos necesarios que necesita el sistema es siempre algo positivo.
No sirve de nada un modelo con un 99\% de acierto si necesita más del tiempo crítico para realizar la predicción.

Por ello, paralelamente a buscar la mejor solución, en un proyecto real sería necesario balancear la solución con los recursos disponibles.

En caso de faltar recursos para realizar la predicción, se podría barajar la implementación de una solución 'b' que sea menos precisa pero más rápida.

La aplicación también debe ser optimizada según el número de usuarios que se espera que la utilicen.
En caso de que el número de usuarios sea muy elevado, se debería estudiar la posibilidad de utilizar un servidor más potente, o incluso utilizar varios servidores en paralelo.
El uso de contenedores facilita esta tarea, ya que se podrían desplegar instancias del servidor web en varios servidores y balancear la carga entre ellos.





\endinput